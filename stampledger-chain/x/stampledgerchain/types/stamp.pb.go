// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stampledgerchain/stampledgerchain/v1/stamp.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Stamp represents a PE stamp record on the blockchain
type Stamp struct {
	Id             string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	DocumentHash   string `protobuf:"bytes,2,opt,name=document_hash,json=documentHash,proto3" json:"document_hash,omitempty"`
	PePublicKey    string `protobuf:"bytes,3,opt,name=pe_public_key,json=pePublicKey,proto3" json:"pe_public_key,omitempty"`
	Signature      string `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	JurisdictionId string `protobuf:"bytes,5,opt,name=jurisdiction_id,json=jurisdictionId,proto3" json:"jurisdiction_id,omitempty"`
	CreatedAt      int64  `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Creator        string `protobuf:"bytes,7,opt,name=creator,proto3" json:"creator,omitempty"`
	Revoked        bool   `protobuf:"varint,8,opt,name=revoked,proto3" json:"revoked,omitempty"`
	RevokedAt      int64  `protobuf:"varint,9,opt,name=revoked_at,json=revokedAt,proto3" json:"revoked_at,omitempty"`
	RevokedReason  string `protobuf:"bytes,10,opt,name=revoked_reason,json=revokedReason,proto3" json:"revoked_reason,omitempty"`
	// PE metadata
	PeLicenseNumber string `protobuf:"bytes,11,opt,name=pe_license_number,json=peLicenseNumber,proto3" json:"pe_license_number,omitempty"`
	PeName          string `protobuf:"bytes,12,opt,name=pe_name,json=peName,proto3" json:"pe_name,omitempty"`
	ProjectName     string `protobuf:"bytes,13,opt,name=project_name,json=projectName,proto3" json:"project_name,omitempty"`
	// Document storage (IPFS integration)
	DocumentIpfsHash string `protobuf:"bytes,14,opt,name=document_ipfs_hash,json=documentIpfsHash,proto3" json:"document_ipfs_hash,omitempty"`
	DocumentSize     int64  `protobuf:"varint,15,opt,name=document_size,json=documentSize,proto3" json:"document_size,omitempty"`
	DocumentFilename string `protobuf:"bytes,16,opt,name=document_filename,json=documentFilename,proto3" json:"document_filename,omitempty"`
}

func (m *Stamp) Reset()         { *m = Stamp{} }
func (m *Stamp) String() string { return proto.CompactTextString(m) }
func (*Stamp) ProtoMessage()    {}
func (*Stamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd5c3d9e6d4a1f93, []int{0}
}
func (m *Stamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stamp.Merge(m, src)
}
func (m *Stamp) XXX_Size() int {
	return m.Size()
}
func (m *Stamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Stamp.DiscardUnknown(m)
}

var xxx_messageInfo_Stamp proto.InternalMessageInfo

func (m *Stamp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Stamp) GetDocumentHash() string {
	if m != nil {
		return m.DocumentHash
	}
	return ""
}

func (m *Stamp) GetPePublicKey() string {
	if m != nil {
		return m.PePublicKey
	}
	return ""
}

func (m *Stamp) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *Stamp) GetJurisdictionId() string {
	if m != nil {
		return m.JurisdictionId
	}
	return ""
}

func (m *Stamp) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Stamp) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *Stamp) GetRevoked() bool {
	if m != nil {
		return m.Revoked
	}
	return false
}

func (m *Stamp) GetRevokedAt() int64 {
	if m != nil {
		return m.RevokedAt
	}
	return 0
}

func (m *Stamp) GetRevokedReason() string {
	if m != nil {
		return m.RevokedReason
	}
	return ""
}

func (m *Stamp) GetPeLicenseNumber() string {
	if m != nil {
		return m.PeLicenseNumber
	}
	return ""
}

func (m *Stamp) GetPeName() string {
	if m != nil {
		return m.PeName
	}
	return ""
}

func (m *Stamp) GetProjectName() string {
	if m != nil {
		return m.ProjectName
	}
	return ""
}

func (m *Stamp) GetDocumentIpfsHash() string {
	if m != nil {
		return m.DocumentIpfsHash
	}
	return ""
}

func (m *Stamp) GetDocumentSize() int64 {
	if m != nil {
		return m.DocumentSize
	}
	return 0
}

func (m *Stamp) GetDocumentFilename() string {
	if m != nil {
		return m.DocumentFilename
	}
	return ""
}

// DocumentStorage for immutable document storage
type DocumentStorage struct {
	Id         string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	StampId    string `protobuf:"bytes,2,opt,name=stamp_id,json=stampId,proto3" json:"stamp_id,omitempty"`
	IpfsHash   string `protobuf:"bytes,3,opt,name=ipfs_hash,json=ipfsHash,proto3" json:"ipfs_hash,omitempty"`
	Filename   string `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
	Size_      int64  `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	MimeType   string `protobuf:"bytes,6,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	UploadedAt int64  `protobuf:"varint,7,opt,name=uploaded_at,json=uploadedAt,proto3" json:"uploaded_at,omitempty"`
	UploadedBy string `protobuf:"bytes,8,opt,name=uploaded_by,json=uploadedBy,proto3" json:"uploaded_by,omitempty"`
	Pinned     bool   `protobuf:"varint,9,opt,name=pinned,proto3" json:"pinned,omitempty"`
}

func (m *DocumentStorage) Reset()         { *m = DocumentStorage{} }
func (m *DocumentStorage) String() string { return proto.CompactTextString(m) }
func (*DocumentStorage) ProtoMessage()    {}
func (*DocumentStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd5c3d9e6d4a1f93, []int{1}
}
func (m *DocumentStorage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentStorage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentStorage.Merge(m, src)
}
func (m *DocumentStorage) XXX_Size() int {
	return m.Size()
}
func (m *DocumentStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentStorage.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentStorage proto.InternalMessageInfo

func (m *DocumentStorage) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DocumentStorage) GetStampId() string {
	if m != nil {
		return m.StampId
	}
	return ""
}

func (m *DocumentStorage) GetIpfsHash() string {
	if m != nil {
		return m.IpfsHash
	}
	return ""
}

func (m *DocumentStorage) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *DocumentStorage) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *DocumentStorage) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *DocumentStorage) GetUploadedAt() int64 {
	if m != nil {
		return m.UploadedAt
	}
	return 0
}

func (m *DocumentStorage) GetUploadedBy() string {
	if m != nil {
		return m.UploadedBy
	}
	return ""
}

func (m *DocumentStorage) GetPinned() bool {
	if m != nil {
		return m.Pinned
	}
	return false
}

// EntityAccount for organizations (companies, municipalities, firms)
type EntityAccount struct {
	Id              string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name            string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	EntityType      string   `protobuf:"bytes,3,opt,name=entity_type,json=entityType,proto3" json:"entity_type,omitempty"`
	OwnerAddress    string   `protobuf:"bytes,4,opt,name=owner_address,json=ownerAddress,proto3" json:"owner_address,omitempty"`
	MemberAddresses []string `protobuf:"bytes,5,rep,name=member_addresses,json=memberAddresses,proto3" json:"member_addresses,omitempty"`
	AdminAddresses  []string `protobuf:"bytes,6,rep,name=admin_addresses,json=adminAddresses,proto3" json:"admin_addresses,omitempty"`
	CreatedAt       int64    `protobuf:"varint,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Active          bool     `protobuf:"varint,8,opt,name=active,proto3" json:"active,omitempty"`
	// Permissions map: address -> role (viewer, editor, admin)
	Permissions map[string]string `protobuf:"bytes,9,rep,name=permissions,proto3" json:"permissions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EntityAccount) Reset()         { *m = EntityAccount{} }
func (m *EntityAccount) String() string { return proto.CompactTextString(m) }
func (*EntityAccount) ProtoMessage()    {}
func (*EntityAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd5c3d9e6d4a1f93, []int{2}
}
func (m *EntityAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntityAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntityAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntityAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityAccount.Merge(m, src)
}
func (m *EntityAccount) XXX_Size() int {
	return m.Size()
}
func (m *EntityAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityAccount.DiscardUnknown(m)
}

var xxx_messageInfo_EntityAccount proto.InternalMessageInfo

func (m *EntityAccount) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *EntityAccount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EntityAccount) GetEntityType() string {
	if m != nil {
		return m.EntityType
	}
	return ""
}

func (m *EntityAccount) GetOwnerAddress() string {
	if m != nil {
		return m.OwnerAddress
	}
	return ""
}

func (m *EntityAccount) GetMemberAddresses() []string {
	if m != nil {
		return m.MemberAddresses
	}
	return nil
}

func (m *EntityAccount) GetAdminAddresses() []string {
	if m != nil {
		return m.AdminAddresses
	}
	return nil
}

func (m *EntityAccount) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *EntityAccount) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *EntityAccount) GetPermissions() map[string]string {
	if m != nil {
		return m.Permissions
	}
	return nil
}

// SpecVersion for specification tracking with version history
type SpecVersion struct {
	Id              string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ProjectId       string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	Version         string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	SpecHash        string `protobuf:"bytes,4,opt,name=spec_hash,json=specHash,proto3" json:"spec_hash,omitempty"`
	SpecIpfs        string `protobuf:"bytes,5,opt,name=spec_ipfs,json=specIpfs,proto3" json:"spec_ipfs,omitempty"`
	CreatedAt       int64  `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	CreatedBy       string `protobuf:"bytes,7,opt,name=created_by,json=createdBy,proto3" json:"created_by,omitempty"`
	Changelog       string `protobuf:"bytes,8,opt,name=changelog,proto3" json:"changelog,omitempty"`
	ParentVersionId string `protobuf:"bytes,9,opt,name=parent_version_id,json=parentVersionId,proto3" json:"parent_version_id,omitempty"`
}

func (m *SpecVersion) Reset()         { *m = SpecVersion{} }
func (m *SpecVersion) String() string { return proto.CompactTextString(m) }
func (*SpecVersion) ProtoMessage()    {}
func (*SpecVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd5c3d9e6d4a1f93, []int{3}
}
func (m *SpecVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecVersion.Merge(m, src)
}
func (m *SpecVersion) XXX_Size() int {
	return m.Size()
}
func (m *SpecVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecVersion.DiscardUnknown(m)
}

var xxx_messageInfo_SpecVersion proto.InternalMessageInfo

func (m *SpecVersion) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SpecVersion) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *SpecVersion) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SpecVersion) GetSpecHash() string {
	if m != nil {
		return m.SpecHash
	}
	return ""
}

func (m *SpecVersion) GetSpecIpfs() string {
	if m != nil {
		return m.SpecIpfs
	}
	return ""
}

func (m *SpecVersion) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *SpecVersion) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *SpecVersion) GetChangelog() string {
	if m != nil {
		return m.Changelog
	}
	return ""
}

func (m *SpecVersion) GetParentVersionId() string {
	if m != nil {
		return m.ParentVersionId
	}
	return ""
}

func init() {
	proto.RegisterType((*Stamp)(nil), "stampledgerchain.stampledgerchain.v1.Stamp")
	proto.RegisterType((*DocumentStorage)(nil), "stampledgerchain.stampledgerchain.v1.DocumentStorage")
	proto.RegisterType((*EntityAccount)(nil), "stampledgerchain.stampledgerchain.v1.EntityAccount")
	proto.RegisterMapType((map[string]string)(nil), "stampledgerchain.stampledgerchain.v1.EntityAccount.PermissionsEntry")
	proto.RegisterType((*SpecVersion)(nil), "stampledgerchain.stampledgerchain.v1.SpecVersion")
}

func init() {
	proto.RegisterFile("stampledgerchain/stampledgerchain/v1/stamp.proto", fileDescriptor_cd5c3d9e6d4a1f93)
}

var fileDescriptor_cd5c3d9e6d4a1f93 = []byte{
	// 862 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0x8e, 0xff, 0x3d, 0xe5, 0xd8, 0x71, 0x5a, 0xab, 0x65, 0x08, 0xac, 0xd7, 0x64, 0x41, 0x84,
	0x05, 0x1c, 0x16, 0x2e, 0x68, 0x0f, 0x48, 0x8e, 0xb2, 0x08, 0x0b, 0xb4, 0x5a, 0x39, 0x88, 0x03,
	0x97, 0x51, 0x7b, 0xa6, 0x62, 0xf7, 0xae, 0xa7, 0xa7, 0x35, 0xdd, 0x36, 0x78, 0x1f, 0x80, 0x33,
	0x4f, 0x80, 0x78, 0x02, 0x0e, 0x3c, 0x05, 0xc7, 0x1c, 0x39, 0xa2, 0xe4, 0xc2, 0x63, 0xa0, 0xae,
	0xee, 0xb1, 0x9d, 0xf8, 0xc0, 0x5e, 0xac, 0xae, 0xaf, 0xbe, 0x2e, 0x57, 0x57, 0x7d, 0x55, 0x03,
	0x9f, 0x69, 0xc3, 0x53, 0x35, 0xc7, 0x64, 0x8a, 0x79, 0x3c, 0xe3, 0x42, 0x9e, 0xee, 0x00, 0xcb,
	0x27, 0x0e, 0x1b, 0xa8, 0x3c, 0x33, 0x19, 0x7b, 0xff, 0x2e, 0x61, 0xb0, 0x03, 0x2c, 0x9f, 0x1c,
	0x1d, 0xf2, 0x54, 0xc8, 0xec, 0x94, 0x7e, 0xdd, 0xc5, 0xa3, 0x7b, 0xd3, 0x6c, 0x9a, 0xd1, 0xf1,
	0xd4, 0x9e, 0x1c, 0x7a, 0xfc, 0x47, 0x15, 0x6a, 0x17, 0x36, 0x00, 0xeb, 0x40, 0x59, 0x24, 0x61,
	0xa9, 0x5f, 0x3a, 0x09, 0xc6, 0x65, 0x91, 0xb0, 0x47, 0xd0, 0x4e, 0xb2, 0x78, 0x91, 0xa2, 0x34,
	0xd1, 0x8c, 0xeb, 0x59, 0x58, 0x26, 0xd7, 0x7e, 0x01, 0x7e, 0xc3, 0xf5, 0x8c, 0x1d, 0x43, 0x5b,
	0x61, 0xa4, 0x16, 0x93, 0xb9, 0x88, 0xa3, 0x57, 0xb8, 0x0a, 0x2b, 0x44, 0x6a, 0x29, 0x7c, 0x41,
	0xd8, 0xb7, 0xb8, 0x62, 0xef, 0x42, 0xa0, 0xc5, 0x54, 0x72, 0xb3, 0xc8, 0x31, 0xac, 0x92, 0x7f,
	0x03, 0xb0, 0x0f, 0xe1, 0xe0, 0xe5, 0x22, 0x17, 0x3a, 0x11, 0xb1, 0x11, 0x99, 0x8c, 0x44, 0x12,
	0xd6, 0x88, 0xd3, 0xd9, 0x86, 0x47, 0x09, 0x7b, 0x00, 0x10, 0xe7, 0xc8, 0x0d, 0x26, 0x11, 0x37,
	0x61, 0xbd, 0x5f, 0x3a, 0xa9, 0x8c, 0x03, 0x8f, 0x0c, 0x0d, 0x0b, 0xa1, 0x41, 0x46, 0x96, 0x87,
	0x0d, 0xba, 0x5f, 0x98, 0xd6, 0x93, 0xe3, 0x32, 0x7b, 0x85, 0x49, 0xd8, 0xec, 0x97, 0x4e, 0x9a,
	0xe3, 0xc2, 0xb4, 0x21, 0xfd, 0xd1, 0x86, 0x0c, 0x5c, 0x48, 0x8f, 0x0c, 0x0d, 0xfb, 0x00, 0x3a,
	0x85, 0x3b, 0x47, 0xae, 0x33, 0x19, 0x02, 0x45, 0x6e, 0x7b, 0x74, 0x4c, 0x20, 0x7b, 0x0c, 0x87,
	0x0a, 0xa3, 0xb9, 0x88, 0x51, 0x6a, 0x8c, 0xe4, 0x22, 0x9d, 0x60, 0x1e, 0xb6, 0x88, 0x79, 0xa0,
	0xf0, 0x3b, 0x87, 0x3f, 0x27, 0x98, 0xbd, 0x05, 0x0d, 0x85, 0x91, 0xe4, 0x29, 0x86, 0xfb, 0xc4,
	0xa8, 0x2b, 0x7c, 0xce, 0x53, 0x64, 0xef, 0xc1, 0xbe, 0xca, 0xb3, 0x97, 0x18, 0x1b, 0xe7, 0x6d,
	0xfb, 0x3a, 0x3a, 0x8c, 0x28, 0x9f, 0x00, 0x5b, 0x37, 0x44, 0xa8, 0x4b, 0xed, 0xba, 0xd2, 0x21,
	0x62, 0xb7, 0xf0, 0x8c, 0xd4, 0xa5, 0xa6, 0xce, 0x6c, 0xb7, 0x4f, 0x8b, 0xd7, 0x18, 0x1e, 0xd0,
	0xf3, 0xd6, 0xed, 0xbb, 0x10, 0xaf, 0x91, 0x7d, 0x0c, 0x87, 0x6b, 0xd2, 0xa5, 0x98, 0x23, 0xfd,
	0x75, 0xf7, 0x76, 0xc4, 0xaf, 0x3d, 0xfe, 0xb4, 0xfa, 0xef, 0xef, 0x0f, 0x4b, 0xc7, 0xbf, 0x94,
	0xe1, 0xe0, 0xbc, 0x88, 0x61, 0xb2, 0x9c, 0x4f, 0x71, 0x47, 0x3a, 0x6f, 0x43, 0x93, 0x44, 0x69,
	0x9b, 0xe9, 0x54, 0xd3, 0x20, 0x7b, 0x94, 0xb0, 0x77, 0x20, 0xd8, 0xe4, 0xee, 0xc4, 0xd2, 0x14,
	0x45, 0xce, 0x47, 0xd0, 0x5c, 0x67, 0xe1, 0x84, 0xb2, 0xb6, 0x19, 0x83, 0x2a, 0x3d, 0xa3, 0x46,
	0xcf, 0xa0, 0xb3, 0x0d, 0x96, 0x8a, 0x14, 0x23, 0xb3, 0x52, 0x48, 0x8a, 0x08, 0xc6, 0x4d, 0x0b,
	0x7c, 0xbf, 0x52, 0xc8, 0x1e, 0x42, 0x6b, 0xa1, 0xe6, 0x19, 0x4f, 0x5c, 0x77, 0x1b, 0x74, 0x0f,
	0x0a, 0x68, 0x68, 0x6e, 0x11, 0x26, 0x2b, 0xd2, 0x46, 0xb0, 0x21, 0x9c, 0xad, 0xd8, 0x7d, 0xa8,
	0x2b, 0x21, 0x25, 0x26, 0x24, 0x8d, 0xe6, 0xd8, 0x5b, 0xbe, 0x10, 0x7f, 0x56, 0xa0, 0xfd, 0x4c,
	0x1a, 0x61, 0x56, 0xc3, 0x38, 0xce, 0x16, 0xd2, 0xec, 0x94, 0x81, 0x41, 0x95, 0x9e, 0xe2, 0x4a,
	0x40, 0x67, 0xfb, 0xa7, 0x48, 0x97, 0x5c, 0xd2, 0xae, 0x02, 0xe0, 0x20, 0x4a, 0xfb, 0x11, 0xb4,
	0xb3, 0x9f, 0x24, 0xe6, 0x11, 0x4f, 0x92, 0x1c, 0xb5, 0xf6, 0x85, 0xd8, 0x27, 0x70, 0xe8, 0x30,
	0xf6, 0x11, 0x74, 0x53, 0xb4, 0x82, 0x2a, 0x58, 0xa8, 0xc3, 0x5a, 0xbf, 0x62, 0x15, 0xe7, 0xf0,
	0x61, 0x01, 0xdb, 0xf9, 0xe2, 0x49, 0x2a, 0xe4, 0x16, 0xb3, 0x4e, 0xcc, 0x0e, 0xc1, 0x1b, 0xe2,
	0xed, 0xf9, 0x6a, 0xdc, 0x9d, 0xaf, 0xfb, 0x50, 0xe7, 0xb1, 0x11, 0x4b, 0xf4, 0x43, 0xe4, 0x2d,
	0x76, 0x09, 0x2d, 0x85, 0x79, 0x2a, 0xb4, 0x16, 0x99, 0xd4, 0x61, 0xd0, 0xaf, 0x9c, 0xb4, 0x3e,
	0x3f, 0x1f, 0xbc, 0xc9, 0x96, 0x1a, 0xdc, 0x2a, 0xdf, 0xe0, 0xc5, 0x26, 0xcc, 0x33, 0x69, 0xf2,
	0xd5, 0x78, 0x3b, 0xf0, 0xd1, 0x57, 0xd0, 0xbd, 0x4b, 0x60, 0x5d, 0xa8, 0xd8, 0x9d, 0xe3, 0x2a,
	0x6e, 0x8f, 0xec, 0x1e, 0xd4, 0x96, 0x7c, 0xbe, 0x28, 0x6a, 0xee, 0x8c, 0xa7, 0xe5, 0x2f, 0x4b,
	0xbe, 0x69, 0xbf, 0x95, 0xa1, 0x75, 0xa1, 0x30, 0xfe, 0x01, 0x73, 0x1b, 0x67, 0xa7, 0x65, 0x0f,
	0x00, 0x8a, 0x31, 0x5c, 0x6b, 0x37, 0xf0, 0xc8, 0x28, 0xb1, 0xab, 0x64, 0xe9, 0x6e, 0xfa, 0xce,
	0x15, 0xa6, 0x95, 0xa2, 0x56, 0x18, 0x3b, 0x5d, 0x7b, 0xed, 0x5a, 0x80, 0x74, 0x5d, 0x38, 0xad,
	0xd0, 0xfd, 0x76, 0x23, 0xa7, 0x1d, 0xd6, 0xff, 0xdb, 0x6b, 0x5b, 0xee, 0xc9, 0xca, 0xaf, 0xb6,
	0xc2, 0x7d, 0x46, 0xcb, 0x35, 0x9e, 0x71, 0x39, 0xc5, 0x79, 0x36, 0xf5, 0x12, 0xde, 0x00, 0xb4,
	0x9a, 0x78, 0x6e, 0xa7, 0xdb, 0xe7, 0x69, 0x5f, 0x15, 0xf8, 0xd5, 0x44, 0x0e, 0x5f, 0x88, 0x91,
	0x57, 0xf5, 0xd9, 0xf9, 0x5f, 0xd7, 0xbd, 0xd2, 0xd5, 0x75, 0xaf, 0xf4, 0xcf, 0x75, 0xaf, 0xf4,
	0xeb, 0x4d, 0x6f, 0xef, 0xea, 0xa6, 0xb7, 0xf7, 0xf7, 0x4d, 0x6f, 0xef, 0xc7, 0xc7, 0x5b, 0x1d,
	0xfc, 0xd4, 0x7d, 0x9a, 0x7e, 0xde, 0xfd, 0x5a, 0x59, 0x55, 0xeb, 0x49, 0x9d, 0x3e, 0x2e, 0x5f,
	0xfc, 0x17, 0x00, 0x00, 0xff, 0xff, 0x18, 0xd2, 0xdb, 0xcb, 0xdf, 0x06, 0x00, 0x00,
}

func (this *Stamp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Stamp)
	if !ok {
		that2, ok := that.(Stamp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.DocumentHash != that1.DocumentHash {
		return false
	}
	if this.PePublicKey != that1.PePublicKey {
		return false
	}
	if this.Signature != that1.Signature {
		return false
	}
	if this.JurisdictionId != that1.JurisdictionId {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.Creator != that1.Creator {
		return false
	}
	if this.Revoked != that1.Revoked {
		return false
	}
	if this.RevokedAt != that1.RevokedAt {
		return false
	}
	if this.RevokedReason != that1.RevokedReason {
		return false
	}
	if this.PeLicenseNumber != that1.PeLicenseNumber {
		return false
	}
	if this.PeName != that1.PeName {
		return false
	}
	if this.ProjectName != that1.ProjectName {
		return false
	}
	if this.DocumentIpfsHash != that1.DocumentIpfsHash {
		return false
	}
	if this.DocumentSize != that1.DocumentSize {
		return false
	}
	if this.DocumentFilename != that1.DocumentFilename {
		return false
	}
	return true
}
func (this *DocumentStorage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DocumentStorage)
	if !ok {
		that2, ok := that.(DocumentStorage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.StampId != that1.StampId {
		return false
	}
	if this.IpfsHash != that1.IpfsHash {
		return false
	}
	if this.Filename != that1.Filename {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.MimeType != that1.MimeType {
		return false
	}
	if this.UploadedAt != that1.UploadedAt {
		return false
	}
	if this.UploadedBy != that1.UploadedBy {
		return false
	}
	if this.Pinned != that1.Pinned {
		return false
	}
	return true
}
func (this *EntityAccount) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EntityAccount)
	if !ok {
		that2, ok := that.(EntityAccount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.EntityType != that1.EntityType {
		return false
	}
	if this.OwnerAddress != that1.OwnerAddress {
		return false
	}
	if len(this.MemberAddresses) != len(that1.MemberAddresses) {
		return false
	}
	for i := range this.MemberAddresses {
		if this.MemberAddresses[i] != that1.MemberAddresses[i] {
			return false
		}
	}
	if len(this.AdminAddresses) != len(that1.AdminAddresses) {
		return false
	}
	for i := range this.AdminAddresses {
		if this.AdminAddresses[i] != that1.AdminAddresses[i] {
			return false
		}
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.Active != that1.Active {
		return false
	}
	if len(this.Permissions) != len(that1.Permissions) {
		return false
	}
	for i := range this.Permissions {
		if this.Permissions[i] != that1.Permissions[i] {
			return false
		}
	}
	return true
}
func (this *SpecVersion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SpecVersion)
	if !ok {
		that2, ok := that.(SpecVersion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.ProjectId != that1.ProjectId {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.SpecHash != that1.SpecHash {
		return false
	}
	if this.SpecIpfs != that1.SpecIpfs {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.CreatedBy != that1.CreatedBy {
		return false
	}
	if this.Changelog != that1.Changelog {
		return false
	}
	if this.ParentVersionId != that1.ParentVersionId {
		return false
	}
	return true
}
func (m *Stamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DocumentFilename) > 0 {
		i -= len(m.DocumentFilename)
		copy(dAtA[i:], m.DocumentFilename)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.DocumentFilename)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.DocumentSize != 0 {
		i = encodeVarintStamp(dAtA, i, uint64(m.DocumentSize))
		i--
		dAtA[i] = 0x78
	}
	if len(m.DocumentIpfsHash) > 0 {
		i -= len(m.DocumentIpfsHash)
		copy(dAtA[i:], m.DocumentIpfsHash)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.DocumentIpfsHash)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ProjectName) > 0 {
		i -= len(m.ProjectName)
		copy(dAtA[i:], m.ProjectName)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.ProjectName)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.PeName) > 0 {
		i -= len(m.PeName)
		copy(dAtA[i:], m.PeName)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.PeName)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.PeLicenseNumber) > 0 {
		i -= len(m.PeLicenseNumber)
		copy(dAtA[i:], m.PeLicenseNumber)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.PeLicenseNumber)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.RevokedReason) > 0 {
		i -= len(m.RevokedReason)
		copy(dAtA[i:], m.RevokedReason)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.RevokedReason)))
		i--
		dAtA[i] = 0x52
	}
	if m.RevokedAt != 0 {
		i = encodeVarintStamp(dAtA, i, uint64(m.RevokedAt))
		i--
		dAtA[i] = 0x48
	}
	if m.Revoked {
		i--
		if m.Revoked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreatedAt != 0 {
		i = encodeVarintStamp(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x30
	}
	if len(m.JurisdictionId) > 0 {
		i -= len(m.JurisdictionId)
		copy(dAtA[i:], m.JurisdictionId)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.JurisdictionId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PePublicKey) > 0 {
		i -= len(m.PePublicKey)
		copy(dAtA[i:], m.PePublicKey)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.PePublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DocumentHash) > 0 {
		i -= len(m.DocumentHash)
		copy(dAtA[i:], m.DocumentHash)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.DocumentHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DocumentStorage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pinned {
		i--
		if m.Pinned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.UploadedBy) > 0 {
		i -= len(m.UploadedBy)
		copy(dAtA[i:], m.UploadedBy)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.UploadedBy)))
		i--
		dAtA[i] = 0x42
	}
	if m.UploadedAt != 0 {
		i = encodeVarintStamp(dAtA, i, uint64(m.UploadedAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x32
	}
	if m.Size_ != 0 {
		i = encodeVarintStamp(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IpfsHash) > 0 {
		i -= len(m.IpfsHash)
		copy(dAtA[i:], m.IpfsHash)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.IpfsHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StampId) > 0 {
		i -= len(m.StampId)
		copy(dAtA[i:], m.StampId)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.StampId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EntityAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntityAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for k := range m.Permissions {
			v := m.Permissions[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStamp(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStamp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStamp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.CreatedAt != 0 {
		i = encodeVarintStamp(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.AdminAddresses) > 0 {
		for iNdEx := len(m.AdminAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AdminAddresses[iNdEx])
			copy(dAtA[i:], m.AdminAddresses[iNdEx])
			i = encodeVarintStamp(dAtA, i, uint64(len(m.AdminAddresses[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.MemberAddresses) > 0 {
		for iNdEx := len(m.MemberAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MemberAddresses[iNdEx])
			copy(dAtA[i:], m.MemberAddresses[iNdEx])
			i = encodeVarintStamp(dAtA, i, uint64(len(m.MemberAddresses[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.OwnerAddress) > 0 {
		i -= len(m.OwnerAddress)
		copy(dAtA[i:], m.OwnerAddress)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.OwnerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EntityType) > 0 {
		i -= len(m.EntityType)
		copy(dAtA[i:], m.EntityType)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.EntityType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParentVersionId) > 0 {
		i -= len(m.ParentVersionId)
		copy(dAtA[i:], m.ParentVersionId)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.ParentVersionId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Changelog) > 0 {
		i -= len(m.Changelog)
		copy(dAtA[i:], m.Changelog)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.Changelog)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreatedAt != 0 {
		i = encodeVarintStamp(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SpecIpfs) > 0 {
		i -= len(m.SpecIpfs)
		copy(dAtA[i:], m.SpecIpfs)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.SpecIpfs)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SpecHash) > 0 {
		i -= len(m.SpecHash)
		copy(dAtA[i:], m.SpecHash)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.SpecHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintStamp(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintStamp(dAtA []byte, offset int, v uint64) int {
	offset -= sovStamp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Stamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.DocumentHash)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.PePublicKey)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.JurisdictionId)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovStamp(uint64(m.CreatedAt))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	if m.Revoked {
		n += 2
	}
	if m.RevokedAt != 0 {
		n += 1 + sovStamp(uint64(m.RevokedAt))
	}
	l = len(m.RevokedReason)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.PeLicenseNumber)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.PeName)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.ProjectName)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.DocumentIpfsHash)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	if m.DocumentSize != 0 {
		n += 1 + sovStamp(uint64(m.DocumentSize))
	}
	l = len(m.DocumentFilename)
	if l > 0 {
		n += 2 + l + sovStamp(uint64(l))
	}
	return n
}

func (m *DocumentStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.StampId)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.IpfsHash)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovStamp(uint64(m.Size_))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	if m.UploadedAt != 0 {
		n += 1 + sovStamp(uint64(m.UploadedAt))
	}
	l = len(m.UploadedBy)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	if m.Pinned {
		n += 2
	}
	return n
}

func (m *EntityAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.EntityType)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.OwnerAddress)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	if len(m.MemberAddresses) > 0 {
		for _, s := range m.MemberAddresses {
			l = len(s)
			n += 1 + l + sovStamp(uint64(l))
		}
	}
	if len(m.AdminAddresses) > 0 {
		for _, s := range m.AdminAddresses {
			l = len(s)
			n += 1 + l + sovStamp(uint64(l))
		}
	}
	if m.CreatedAt != 0 {
		n += 1 + sovStamp(uint64(m.CreatedAt))
	}
	if m.Active {
		n += 2
	}
	if len(m.Permissions) > 0 {
		for k, v := range m.Permissions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStamp(uint64(len(k))) + 1 + len(v) + sovStamp(uint64(len(v)))
			n += mapEntrySize + 1 + sovStamp(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SpecVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.SpecHash)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.SpecIpfs)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovStamp(uint64(m.CreatedAt))
	}
	l = len(m.CreatedBy)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.Changelog)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	l = len(m.ParentVersionId)
	if l > 0 {
		n += 1 + l + sovStamp(uint64(l))
	}
	return n
}

func sovStamp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStamp(x uint64) (n int) {
	return sovStamp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Stamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PePublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PePublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JurisdictionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JurisdictionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revoked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Revoked = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokedAt", wireType)
			}
			m.RevokedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevokedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokedReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevokedReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeLicenseNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeLicenseNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentIpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentIpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentSize", wireType)
			}
			m.DocumentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocumentSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentFilename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentFilename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentStorage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentStorage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentStorage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StampId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StampId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpfsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpfsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadedAt", wireType)
			}
			m.UploadedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pinned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pinned = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemberAddresses = append(m.MemberAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminAddresses = append(m.AdminAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStamp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStamp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStamp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStamp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStamp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStamp
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStamp
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStamp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStamp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Permissions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStamp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpecHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecIpfs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpecIpfs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changelog", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changelog = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentVersionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStamp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStamp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentVersionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStamp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStamp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStamp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStamp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStamp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStamp
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStamp
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStamp
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStamp        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStamp          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStamp = fmt.Errorf("proto: unexpected end of group")
)
